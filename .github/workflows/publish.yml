name: Publish Release

on:
  workflow_call:
    inputs:
      matrix:
        required: true
        type: string
      build_date:
        required: true
        type: string
      should_release:
        required: true
        type: string
      base_image_tag:
        required: true
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  BASE_IMAGE_NAME: ${{ github.repository }}/base
  KEEP_LAST_N: 10

jobs:
  create-release:
    runs-on: ubuntu-latest
    if: inputs.should_release == 'true'
    permissions:
      contents: write
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download all manifests
        uses: actions/download-artifact@v4
        with:
          pattern: package-manifest-*
          path: manifests/

      - name: Download test results
        uses: actions/download-artifact@v4
        with:
          pattern: test-results-*
          path: test-results/

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Get TeX Live version
        id: texlive-version
        run: |
          # Get version from the base image
          docker pull ${{ env.REGISTRY }}/${{ env.BASE_IMAGE_NAME }}:${{ inputs.base_image_tag }}
          TEXLIVE_VERSION=$(docker run --rm ${{ env.REGISTRY }}/${{ env.BASE_IMAGE_NAME }}:${{ inputs.base_image_tag }} bash -c 'export $(grep -v "^#" /etc/environment | xargs -d "\n") && echo $LIVE_YEAR')
          echo "version=${TEXLIVE_VERSION}" >> $GITHUB_OUTPUT

      - name: Create release notes
        run: |
          cat > release-notes.md << EOF
          # LaTeX Compiler Docker Images - TeX Live ${{ steps.texlive-version.outputs.version }}

          **Build Date:** ${{ inputs.build_date }}
          **TeX Live Version:** ${{ steps.texlive-version.outputs.version }}

          ## Available Variants

          ### Minimal Variant
          - **Image:** \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest\`
          - **Image:** \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.texlive-version.outputs.version }}\`
          - **Description:** Essential LaTeX packages for basic document compilation
          - **Use case:** Simple documents, faster builds, smaller image size

          ### Standard Variant
          - **Image:** \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest-standard\`
          - **Image:** \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.texlive-version.outputs.version }}-standard\`
          - **Description:** Balanced selection of LaTeX packages for most common documents
          - **Use case:** Academic papers, reports, presentations with moderate complexity

          ### Full Variant  
          - **Image:** \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest-full\`
          - **Image:** \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.texlive-version.outputs.version }}-full\`
          - **Description:** Comprehensive LaTeX package set for complex documents
          - **Use case:** Scientific papers, complex formatting, extensive package requirements

          ## Usage Examples

          \`\`\`bash
          # Minimal variant
          docker run --rm -v \$(pwd):/data ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest compile.sh

          # Standard variant
          docker run --rm -v \$(pwd):/data ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest-standard compile.sh

          # Full variant
          docker run --rm -v \$(pwd):/data ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest-full compile.sh
          \`\`\`
          
          ## What's Included
          
          - TeX Live ${{ steps.texlive-version.outputs.version }}
          - Built-in compilation helper script with error handling
          - Multi-architecture support (linux/amd64, linux/arm64)
          - Automatic two-pass compilation for references
          - Colored output and cleanup options
          
          ## Testing
          
          All variants have been tested with comprehensive test suites:
          - **Basic tests:** Core LaTeX functionality
          - **Package-specific tests:** Variant-specific package testing
          - **Compilation verification:** PDF generation confirmed
          
          ## Package Manifests
          
          Detailed package lists for each variant are attached to this release.
          
          ## Changes in this Release
          
          - Updated to TeX Live ${{ steps.texlive-version.outputs.version }}
          - Refreshed all package repositories
          - Updated base system packages
          - Optimized build process with multi-stage Docker builds
          - Verified compilation functionality with automated test suites
          EOF

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: texlive-${{ steps.texlive-version.outputs.version }}-${{ inputs.build_date }}
          name: TeX Live ${{ steps.texlive-version.outputs.version }} - ${{ inputs.build_date }}
          body_path: release-notes.md
          files: |
            manifests/**/*.md
            test-results/**/*.pdf
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Release summary
        run: |
          echo "## ðŸš€ Release Created" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** texlive-${{ steps.texlive-version.outputs.version }}-${{ inputs.build_date }}" >> $GITHUB_STEP_SUMMARY
          echo "**TeX Live Version:** ${{ steps.texlive-version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Build Date:** ${{ inputs.build_date }}" >> $GITHUB_STEP_SUMMARY
          echo "**Variants:** minimal, standard, full" >> $GITHUB_STEP_SUMMARY
          echo "**Test Results:** All variants tested successfully" >> $GITHUB_STEP_SUMMARY

      - name: Clean up old Docker images
        run: |
          # Get repository name in lowercase for GHCR
          REPO_NAME=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]' | cut -d'/' -f2)
          OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          KEEP_LAST_N=5  # Define how many recent images to keep
          
          echo "Fetching all package versions for $OWNER/$REPO_NAME..."

          # First, check if this is a user or organization package
          ORG_RESPONSE=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/orgs/$OWNER")
          
          if [[ $(echo "$ORG_RESPONSE" | jq -r 'if has("message") then .message else "" end') == "Not Found" ]]; then
            # This is a user package
            echo "Repository belongs to a user account"
            API_URL="https://api.github.com/user/packages/container/$REPO_NAME/versions?per_page=100"
          else
            # This is an organization package
            echo "Repository belongs to an organization account"
            API_URL="https://api.github.com/orgs/$OWNER/packages/container/$REPO_NAME/versions?per_page=100"
          fi
          
          echo "Using API URL: $API_URL"
          
          # Fetch package versions
          RESPONSE=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" "$API_URL")

          # Check if the response is valid JSON and contains data
          if ! echo "$RESPONSE" | jq -e . > /dev/null 2>&1; then
            echo "Error: Invalid JSON response from GitHub API"
            echo "Response: $RESPONSE"
            exit 1
          fi
          
          # Check if we got an error message (only if response is an object)
          if echo "$RESPONSE" | jq 'type' | grep -q "object"; then
          ERROR_MESSAGE=$(echo "$RESPONSE" | jq -r 'if has("message") then .message else "" end')
          if [[ -n "$ERROR_MESSAGE" ]]; then
            echo "Error from GitHub API: $ERROR_MESSAGE"
            echo "Full response: $RESPONSE"
            echo "Skipping cleanup due to API error"
            exit 0
          fi
          fi
          
          # Check if we got an array of package versions
          if [ "$(echo "$RESPONSE" | jq 'type')" != '"array"' ]; then
            echo "Error: Unexpected response format from GitHub API"
            echo "Response type: $(echo "$RESPONSE" | jq 'type')"
            echo "Response: $RESPONSE"
            exit 1
          fi

          # Process the response with proper error handling
          PACKAGE_VERSIONS=$(echo "$RESPONSE" | jq -r '.[] | {id: .id, created_at: .created_at, digest: .name, tags: (.metadata.container.tags // [])}')

          # Check if we have any versions
          if [[ -z "$PACKAGE_VERSIONS" ]]; then
            echo "No package versions found to clean up"
            exit 0
          fi

          # Sort versions by creation date (newest first)
          SORTED_VERSIONS=$(echo "$PACKAGE_VERSIONS" | jq -s 'sort_by(.created_at) | reverse')
          
          # Keep the latest N non-base images and delete the rest
          echo "Identifying images to keep and delete..."
          
          # Keep all images that don't have "-base" in their tags
          KEEP_IDS=$(echo "$SORTED_VERSIONS" | jq -r '.[] | select(.tags | map(contains("-base") | not) | all) | .id' | head -n $KEEP_LAST_N)
          
          # Also keep the latest base image
          LATEST_BASE_ID=$(echo "$SORTED_VERSIONS" | jq -r '.[] | select(.tags | map(contains("-base")) | any) | .id' | head -n 1)
          
          # Combine IDs to keep
          ALL_KEEP_IDS="$KEEP_IDS $LATEST_BASE_ID"
          
          # Get all IDs
          ALL_IDS=$(echo "$SORTED_VERSIONS" | jq -r '.[].id')
          
          # Find IDs to delete (those not in the keep list)
          DELETE_IDS=$(comm -23 <(echo "$ALL_IDS" | sort) <(echo "$ALL_KEEP_IDS" | tr ' ' '\n' | sort))
          
          # Count versions to delete
          DELETE_COUNT=$(echo "$DELETE_IDS" | wc -l)
          echo "Deleting $DELETE_COUNT older versions"
          
          # Delete older versions
          for ID in $DELETE_IDS; do
            echo "Deleting package version ID: $ID"
          
            # Use the appropriate API endpoint based on user/org determination
            if [[ $(echo "$ORG_RESPONSE" | jq -r 'if has("message") then .message else "" end') == "Not Found" ]]; then
              # User package
              DELETE_URL="https://api.github.com/user/packages/container/$REPO_NAME/versions/$ID"
            else
              # Organization package
              DELETE_URL="https://api.github.com/orgs/$OWNER/packages/container/$REPO_NAME/versions/$ID"
            fi
          
            curl -X DELETE \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "$DELETE_URL"

            # Add a small delay to avoid rate limiting
            sleep 1
          done
          
          echo "Cleanup complete. Kept the latest $KEEP_LAST_N versions and the latest base image."
