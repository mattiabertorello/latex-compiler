name: Temporary Cleanup of Old Repositories

on:
  workflow_dispatch:
    inputs:
      keep_last_n_tagged:
        description: 'Number of recent tagged images to keep'
        required: true
        default: '10'
permissions:
  contents: read
  packages: write

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Clean up old repositories
        run: |
          # Configuration
          OWNER="mattiabertorello"
          REPOSITORIES=("latex-compiler%2Fbase" "latex-compiler")
          KEEP_LAST_N_TAGGED="${{ github.event.inputs.keep_last_n_tagged }}"
          
          # Function to clean up a repository
          cleanup_repository() {
            local REPO_PATH=$1
            local KEEP_COUNT=$2
          
            # Extract repository name from path
            local REPO_NAME=$(echo "$REPO_PATH" | cut -d'/' -f2)
          
            echo "=== Cleaning up repository: $OWNER/$REPO_PATH ==="
          
            # Check if this is a user or organization package
            ORG_RESPONSE=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/orgs/$OWNER")
          
            # Check if the response contains an error message (for user accounts)
            if echo "$ORG_RESPONSE" | jq -e 'has("message")' > /dev/null 2>&1; then
              ORG_MESSAGE=$(echo "$ORG_RESPONSE" | jq -r '.message')
              if [[ "$ORG_MESSAGE" == "Not Found" ]]; then
                echo "Repository belongs to a user account"
                API_URL="https://api.github.com/user/packages/container/$REPO_NAME/versions?per_page=100"
                BASE_DELETE_URL="https://api.github.com/user/packages/container/$REPO_NAME/versions"
              else
                echo "Error checking organization: $ORG_MESSAGE"
                return 1
              fi
            else
              echo "Repository belongs to an organization account"
              API_URL="https://api.github.com/orgs/$OWNER/packages/container/$REPO_NAME/versions?per_page=100"
              BASE_DELETE_URL="https://api.github.com/orgs/$OWNER/packages/container/$REPO_NAME/versions"
            fi
          
            echo "Using API URL: $API_URL"
          
            # Fetch package versions
            RESPONSE=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" "$API_URL")
          
            # Check if the response is valid JSON
            if ! echo "$RESPONSE" | jq -e . > /dev/null 2>&1; then
              echo "Error: Invalid JSON response from GitHub API"
              echo "Response: $RESPONSE"
              return 1
            fi
          
            # Check response type and handle accordingly
            RESPONSE_TYPE=$(echo "$RESPONSE" | jq 'type')
            echo "Response type: $RESPONSE_TYPE"
          
            if [[ "$RESPONSE_TYPE" == '"array"' ]]; then
              # It's already an array, continue processing
              echo "Response is an array with $(echo "$RESPONSE" | jq 'length') items"
            else
              # Check if we got an error message in an object
              if echo "$RESPONSE" | jq -e 'has("message")' > /dev/null 2>&1; then
                ERROR_MESSAGE=$(echo "$RESPONSE" | jq -r '.message')
                echo "Error from GitHub API: $ERROR_MESSAGE"
                echo "Full response: $RESPONSE"
                echo "Skipping cleanup due to API error"
                return 0
              fi
            fi
          
            # Process the response - handle both array and single object cases
            if [[ "$RESPONSE_TYPE" == '"array"' ]]; then
              PACKAGE_VERSIONS=$(echo "$RESPONSE" | jq -c '.[] | {id: .id, created_at: .created_at, digest: .name, tags: (.metadata.container.tags // [])}')
            else
              echo "Unexpected response format"
              return 1
            fi
          
            # Check if we have any versions
            if [[ -z "$PACKAGE_VERSIONS" ]]; then
              echo "No package versions found to clean up"
              return 0
            fi
          
            # Sort versions by creation date (newest first)
            SORTED_VERSIONS=$(echo "$PACKAGE_VERSIONS" | jq -s 'sort_by(.created_at) | reverse')
          
            # Separate tagged and untagged images
            TAGGED_VERSIONS=$(echo "$SORTED_VERSIONS" | jq '[.[] | select(.tags | length > 0)]')
            UNTAGGED_VERSIONS=$(echo "$SORTED_VERSIONS" | jq '[.[] | select(.tags | length == 0)]')
          
            echo "Found $(echo "$TAGGED_VERSIONS" | jq 'length') tagged versions"
            echo "Found $(echo "$UNTAGGED_VERSIONS" | jq 'length') untagged versions"
          
            # Get IDs of tagged versions to keep
            KEEP_TAGGED_IDS=$(echo "$TAGGED_VERSIONS" | jq -r '.[0:'$KEEP_COUNT'] | .[].id')
          
            # Get IDs of all tagged versions
            ALL_TAGGED_IDS=$(echo "$TAGGED_VERSIONS" | jq -r '.[].id')
          
            # Get IDs of all untagged versions
            ALL_UNTAGGED_IDS=$(echo "$UNTAGGED_VERSIONS" | jq -r '.[].id')
          
            # Find tagged versions to delete (those not in the keep list)
            TAGGED_DELETE_IDS=$(comm -23 <(echo "$ALL_TAGGED_IDS" | sort) <(echo "$KEEP_TAGGED_IDS" | sort))
          
            # Combine all IDs to delete (all untagged + old tagged)
            DELETE_IDS=$(echo -e "$TAGGED_DELETE_IDS\n$ALL_UNTAGGED_IDS" | grep -v '^$')

            # Count versions to delete
            DELETE_COUNT=$(echo "$DELETE_IDS" | grep -v '^$' | wc -l)
            echo "Deleting $DELETE_COUNT versions from $OWNER/$REPO_PATH"
            echo "- $(echo "$TAGGED_DELETE_IDS" | grep -v '^$' | wc -l) old tagged versions"
            echo "- $(echo "$ALL_UNTAGGED_IDS" | grep -v '^$' | wc -l) untagged versions"
          
            # Delete versions
            for ID in $DELETE_IDS; do
              if [[ -z "$ID" ]]; then
                continue
              fi
          
              echo "Deleting package version ID: $ID"
          
              DELETE_URL="$BASE_DELETE_URL/$ID"
          
              RESULT=$(curl -X DELETE -s -o /dev/null -w "%{http_code}" \
                -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github.v3+json" \
                "$DELETE_URL")
          
              if [[ "$RESULT" == "2"* ]]; then
                echo "Successfully deleted version ID: $ID"
              else
                echo "Failed to delete version ID: $ID, status code: $RESULT"
              fi
          
              # Add a small delay to avoid rate limiting
              sleep 1
            done          
            echo "Cleanup complete for $OWNER/$REPO_PATH"
            echo "Kept the latest $KEEP_COUNT tagged versions"
          }
          
          # Process each repository
          for REPO in "${REPOSITORIES[@]}"; do
            cleanup_repository "$REPO" "$KEEP_LAST_N_TAGGED"
            echo ""
          done
